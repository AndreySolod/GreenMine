# GreenMine

Это полностью переработанный проект известного [Pentest Collaboration Framework](https://gitlab.com/invuls/pentest-projects/pcf), созданный как отдельный проект для исправления множества архитектурных недочётов и ошибок оригинального проекта, с сохранением основных идей.

## Основные преимущества

1. Полностью переписанная система миграции - теперь внесение изменений в базу данных осуществляется через SQLAlchemy, что позволяет как автоматически перестраивать базу данных при обновлении, так и избежать большинства ошибок оригинала - когда ни одно ошибочно вгесённое значение нельзя было исправить. Кроме того, доработки и обновления должны стать куда проще;

2. Добавлена и доработана вкладка задач - разработана по примеру большинства приложений для управления проектами;

3. Для большинства объектов добавлены поля "Описание", куда через WYSIWYG-редактор можно вносить дополнительные данные;

4. Для объектов добавлены примечания, куда можно сохранять процесс своей работы в текстовом виде;

5. Добавлена история изменения для большинства объектов - теперь все изменения для большинства объектов логируются и отображаются в отдельной вкладке;

6. Заменена стандартная таблица отображения списка объектов (служб, хостов, проблем и т.д.) на ajax-таблицу, подтягивающую данные для отображения на странице с бек-энда динамически. Это позволит решить проблему как загрузки всей таблицы на страницу и неоправданного расхода памяти (иногда страницы и вообще не грузились), так и проблему отображения длинных полей - для паролей поле "хэш" не заполнялось именно потому, что в противном случае остальные пароли уезжали за пределы страницы;

7. Мелкая доработка - теперь при внесении хэша к списку скомпрометированных учётных записей GreenMine сам предлагает его тип. Кроме того, при выборе типа хэша GreenMine предлагает его HashCat и John-режимы;

8. Для проекта по аналогии с системами управления введены роли пользователей, а также возможности настроить разрешения на действия для соответствующих ролей (например, для наблюдателей - установить возможность только просматривать объекты, но не редактировать их). Введено понятие "администратора" - это человек, обладающий всеми возможными ролями на проекте, и которому доступны все действия (а также доступ к панели администрирования). Также есть лидер проекта - ему доступны все действия, но только на своём проекте.

9. Добавлена панель администратора, на которой можно добавить объекты перечисления (также называемые "Справочниками"), просмотреть список всех файлов, удалить какие-то файлы, добавить шаблоны отчётов/задач/проблем и т.д;

10. Вследствие изменения системы миграции переделаны системы отчётов - теперь каждый шаблон отчётов получает переменную "project", представляющую из себя объект типа "Project", внутри которого и находятся все необходиме данные для создания отчёта;

11. Добавлена поддержка мультиязычности. Приложение переведено на русский и английские языки;

12. Заметки и редактирование заметок переведены на веб-сокеты - это позволяет избежать проблемы с "Несохраняющимися" заметками;

13. Для хостов добавлены поля "MAC-адрес" (с автоматическим определением производителя по MAC-адресу), "Тип устройства", "Производитель устройства", "Модель устройства";

14. Для сервисов добавлено поле "Скриншот веб-интерфейса" - это должно значительно ускорить этап инвентаризации в организации. Кроме того, добавлено поле "техническая информация", которую заполняет импорт из Nmap своими данными из скриптов;

15. Утилиты для экспорта убраны - теперь экспорт можно делать прямо на странице списка всех объектов. Кроме того, доработана фильтрация - теперь фильтрацию можно производить как по всем полям одновременно, так и по каждому полю индивидуально;

16. Убраны почти все утилиты по импорту из других систем (осталась только самая основная - импорт из Nmap/Masscan, причём функционал частично переделан для добавления информации из новых полей. Кроме того, удалена автоматически создаваемая проблема "Message signing enabled, but not required") - вследствие полной переработки общей концепции данных утилит. Теперь они представляют из себя бэкграунд-задачи, что должно решить проблему "Зависшего" веб-интерфейса для пользователей при попытке импорта большого файла. Кроме того, добавлена утилита "Инвентаризатор" - она позволяет указать список портов для сканирования, и сделать их скриншоты веб-интерфейсов (как по http, так и по https);

17. Импорт из Nmap теперь может читать даже файлы незаконченных сканов - если файл невозможно прочитать, он пытается его дописать и прочитать.

18. Сообщения чата - теперь на веб-сокетах, и, что самое главное - они работают!

19. Мелкие правки интерфейса - добавлены аватары пользователей, уведомления (идут через веб-сокеты), возможность выбора темы (цветового оформления), автоматическое заполнение БД изначальными значениями, минификация трафика;

20. Тип хэширования для сохранения паролей - Streebog512;

21. Доработано логирование - теперь можно вести отдельный лог действий пользователя, а не только стандартный лог Flask.

22. Добавлена Content Security Policy, что увеличивает безопасность приложения;

## Что не реализовано из исходного проекта, что планируется реализовать

По текущим доработкам:

- Добавить возможность администратору добавлять новых администраторов;

- Добавить команды - автоматически добавляемые пользователи с соответствующими группами на проекты;

- В проблемы - добавить поле PoC;

- Добавить карту сети;

- Добавить диаграммы состояния по аналогии с оригинальным проектом;

- Добавить WebDAV - для упрощения хранения файлов в проекте. Кроме того, необходимо отключить правую кнопку мыши на файлах - из-за поведения Chrome/Firefox они отображаются некорректно;

- Доработать этап инвентаризации сервисов - отображать их в виде Carousel;

- Доработать безопасность - эндпоинт для CSP-отчётов, парольная политика;

- Доработка User-Frendly - сейчас для первого запуска требуются дополнительные действия.

## Установка зависимостей
### Deb-системы
1. Google Chrome:
Для начала необходимо скачать пакеты зависимостей:

```bash
sudo apt install curl software-properties-common apt-transport-https ca-certificates -y
```
Далее необходимо добавить репозитории и ключи для подписи:

```bash
curl -fSsL https://dl.google.com/linux/linux_signing_key.pub | gpg --dearmor | sudo tee /usr/share/keyrings/google-chrome.gpg > /dev/null
echo deb [arch=amd64 signed-by=/usr/share/keyrings/google-chrome.gpg] http://dl.google.com/linux/chrome/deb/ stable main | sudo tee /etc/apt/sources.list.d/google-chrome.list
```

Теперь обновляем кэш пакетов и устанавливаем Google Chrome:

```bash
sudo apt update
sudo apt install google-chrome-stable
```

## Настройка параметров приложения

При создании нового приложения (после клонирования проекта) необходимо для начала отредактировать файл config.py, где указать свои предпочитаемые настройки, или же передать их через следующие переменные окружения:
- `SECRET_KEY` - указывает на секретный ключ приложения, которым будут шифроваться Cookie-файлы. Желательно указать, поскольку без этого Cookie-файлы не будут валидны между стартом/остановкой приложения;
- `SQLALCHEMY_DATABASE_URI` - путь до базы данных. Задаётся как `Тип БД:///URI`. Например, для использования sqlite значение будет указано как `sqlite:////opt/test_database.db`;
- `REST_FORBIDDEN_ATTRIBUTES` - атрибуты объектов, которые не будут возвращаться или изменяться при REST-запросах. По умолчанию: `User.password_hash,User.token,User.token_expiration`;
- `TOKEN_EXPIRATION` - время жизни токена для REST-запросов. По умолчанию - 1 год;
- `CELERY_BROKER_URL` - адрес БД, выступающей в качестве брокера задач Celery. Желательно использовать Redis. Задаётся в виде: `redis://username:password@localhost:6379/0`. Помимо этого, можно указать протокол Redis Over TLS: `rediss://username:password@localhost:6379/0?ssl_cert_reqs=required`;
- `CELERY_RESULT_BACKEND` - адрес БД, в которую Celery worker'ы будут складывать свои результаты. Задаётся так же, как и `CELERY_BROKER_URL`;
- `CELERY_TASK_IGNORE_RESULT` - указывает, игнорировать ли результаты выполнения задач или нет. Задаётся в виде `True` или `False`;
- `CELERY_WORKERS_COUNT` - указывает на количество worker'ов, которые будут автоматически запущены вместе с приложением. По умолчанию - 1. Для отключения запуска worker'ов необходимо установить этот параметр в 0. Параметр работает только в Debug-режиме;
- `CELERY_WORKERS_CONCURRENCY_COUNT` - количество потоков, приходящееся на каждого рабочего Celery. По умолчанию - 4. Параметр работает только в Debug-режиме;
- `DEFAULT_LANGUAGE` - язык, который будет использоваться для приложения при инициации базы данных. По умолчанию - `ru`;
- `CSP_ENABLED` - будет ли работать Content Security Policy;
- `PAGINATION_ELEMENTS_COUNT_SELECT2` - количество элементов пагинации для плагина Select2 (в форму селекта данные загружаются динамически). По умолчанию - 30;
- `USER_ACTION_LOGGING_IN_STDOUT` - будут ли логироваться действия пользователей на STDOUT. По умолчанию - `True`;
- `USER_ACTION_LOGGING_FILE` - файл, в который будут дополнительно сохраняться действия пользователей. По умолчанию (для Production-конфига) этот файл отсутствует
- `FLASK_LOGGING_ON_STDOUT` - будут ли писаться логи Flask на STDOUT. По умолчанию - True;
- `FLASK_LOGGING_FILE` - файл, в который будут дополнительно сохраняться логи Flask. По умолчанию - отсутствует;
- `ERROR_LOGGING_FILE` - файл, в который будут сохраняться ошибки приложения (ошибка 500). По умолчанию - `/logs/error.log`.

Кроме того, необходимо передавать аргумент `ENVIRONMENT`, устанавливая его в значение `PRODUCTION`, поскольку по умолчанию для целей разработки используется Development-сервер.

Дополнительно можно передать аргумент `APP_PORT`, указывающий на порт, на котором будет слушать приложение. По умолчанию - 5000.

## Основные команды

После установки параметров приложения необходимо проинициализировать базу данных приложения. Для этого используются следующие команды:
- `FLASK_APP=GreenMine flask greenmine-command db-init` - инициирует новую базу данных (даже если она не существовала ранее, как, например, с sqlite). Этот этап можно пропустить - база данных может быть создана на этапе внесения изменений;
- `FLASK_APP=GreenMine flask db migrate` - создаёт новые скрипты миграции для записи данных в базу данных. Этот этап можно пропустить - миграции будут идти вместе с приложением;
- `FLASK_APP=GreenMine flask db upgrade` - вносит изменения в базу данных;
- `FLASK_APP=GreenMine flask greenmine-command load-default-database` - загружает данные по умолчанию в базу данных. Если данные по умолчанию не были внесены на этапе обновления - они будут внесены при первом запуске приложения;

При обновлении базы данных (например, при обновлении проекта) используются следующие команды:
- `FLASK_APP=GreenMine flask db migrate` - создаёт новые скрипты миграции;
- `FLASK_APP=GreenMine flask db upgrade` - вносит изменения в базу данных;
- `FLASK_APP=GreenMine flask greenmine-command update-database-value` - заполняет только что созданные таблицы в базе данных значениями из файла `initial_database_value.yml`;

А при пересоздании базы данных:
- `FLASK_APP=GreenMine flask greenmine-command reset-database` - полностью пересоздаёт существующую базу данных, заполняя её данными из файла `initial_database_value.yml`;
- `FLASK_APP=GreenMine flask greenmine-command recreate-table --table <table_name>` - пересоздаёт указанную таблицу в базе данных (сперва удаляет, потом заново создаёт).

Дополнительно, если были введены новые таблицы с данными по умолчанию, можно использовать команду:
```bash
FLASK_APP=GreenMine flask greenmine-command update-database-value
```

Которая загрузит в пустые таблицы значения из файла `initial_database_value.yml`.

А для пересоздания таблицы и заполнения её значениями из файла `initial_database_value.yml` можно использовать команду:
```bash
FLASK_APP=GreenMine flask greenmine-command recreate-table --table <table_name> 
```

Значение `<table_name>` задаётся в том виде, в котором таблица описана в файле `default_database_value.yml`.

Для обновления переводов приложения предусмотрены 2 команды:
- `FLASK_APP=GreenMine flask translate update` - извлекает все переводы из исходных файлов и помещает в файл messages.pot, после чего обновляет po-файлы в директории app/translations;
- `FLASK_APP=GreenMine flask translate compile` - после того, как исходные po-файлы переводов созданы, данная команда компилирует их в файл .mo. Имеет опцию `-f`, которая позволяет включить в конечный скомпилированный файл перевода так же переводы, помеченные как `fuzzy`.

## Автоматическое исправление ошибок
GreenMine перед самым первым запросом может проводить проверку на наличие минимальных значений в БД, и в случае отсутствия этих значений - автоматически их туда заносить.
По умолчанию проводятся следующие проверки:

- Существует хотя бы один пользователь, который является администратором. Если его не существует - то либо создаётся новый пользователь (Логин/пароль - admin/admin), либо существующему пользователю с логином **admin** выставляется флаг, указывающий на то, что он является администратором;

- Существует Роль на проекте, называемая "Анонимная". Если не существует - она автоматически добавляется в БД;

- В БД присутствует один экземпляр глобальных настроек;

- В БД присутствует язык приложения, имеющий слаг "auto" - т.е. язык приложения будет определяться на основе предпочтений пользователя.

## Логины пользователей

Логины пользователей должны начинаться с буквы, и должны содержать символы алфавита, цифры, символы "-" и "_". Это сделано для того, чтобы их можно было упоминать через CKEditor.

Заводские учётные данные для приложения - `admin/admin` и `worker/worker`.
