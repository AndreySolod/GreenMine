# Принцип работы Import_from_Nmap

При загрузке нового файла сканирования Nmap парсер (xml.etree) пытается открыть и прочитать файл. Если он не может прочитать его - пытается дописать в конец строку \</nmaprun\> и опять прочитать. При повторной ошибке - отказывается обрабатывать файл.

Обработка скриптов вынесена в отдельный файл `nmap_script_processing.py`. Каждый скрипт - это класс, наследующийся от класса `NmapScriptProcessor`, и имеющий следующие атрибуты:
- `script_id` - ID скрипта в том виде, в котором его записывает Nmap;
- `__call__` - Магический метод, который вызывается на данном скрипте в случае, если `script_id` очередного скрипта совпадает с текущим `script_id` класса.

Метод `__call__` получает следующие параметры:

- `script_element` - собственно сам `etreeElement` скрипта, который нужно обработать;
- `session` - это сессия, через которую необходимо взаимодействовать с базой данных;
- `project` - объект класса `Project`, указывающий на текущий проект, на котором происходит обработка файла Nmap;
- `obj_with_script` - это объект, на котором был вызван скрипт. Атрибуты `script` есть как у хостов, так и у портов, поэтому там будет либо текущий хост (`Host`), либо текущий порт (`Service`);
- `current_user_id` - ID пользователя, запустившего импорт из Nmap;
- `locale` - строковый параметр локали (языка интерфейса) пользователя, запустившего скрипт.

Возвращаемое значение скриптов:
- `None` - т.е. либо такого скрипта не существует, либо текущий скрипт не может обработать вывод. В этом случае к технической информации дописывается стандартная строка:
    ```python
    f'\n<h5>Script data:</h5>\n<h6>{script_id}</h6><p>{sanitizer.escape(script_element.get('output')).replace('\n', '<br />')}</p>'
    ```
    Стоит отметить, что скрипты обработки вызываются только в том случае, если `script_id` данного скрипта совпал со значением такового у Nmap, и `None` должно вернуться в том случае, если текущий скрипт не может обработать вывод Nmap;
- Строка - эта строка будет дописана к технической информации (либо хоста, либо сервиса).

Если в процессе обработки скриптов необходимо создать либо задачу, либо проблему - стоит сперва поискать этот объект среди существующих, созданных по шаблону (`sa.select(Issue).where(Issue.by_template_slug == 'my-nmap-script')`), и если не нашли - создавать новую задачу или проблему. Шаблоны проблем должны храниться в файле `default_database_value/issue_template.yml`. При старте приложения проверяется, что все шаблоны проблем существуют, и если каких-то шаблонов нет - добавляются в базу данных.

При создании проблемы и/или задачи по шаблону вручную - ему автоматически проставляется строка `by_template_slug`, которую в дальнейшем может использовать Nmap.
